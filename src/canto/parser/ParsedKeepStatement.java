/* Canto Compiler and Runtime Engine
 * 
 * ParsedKeepStatement.java
 *
 * Copyright (c) 2018 by cantolang.org
 * All rights reserved.
 */

package canto.parser;

import canto.lang.*;

/**
 * Based on code generated by jjtree.
 *
 * @author Michael St. Hippolyte
 * @version $Revision: 1.13 $
 */
public class ParsedKeepStatement extends KeepStatement implements Initializable {

    private boolean hasAs = false;
    private boolean hasAsThis = false;
    private boolean hasDynamicAs = false;
    private boolean hasBy = false;
    private boolean isPrefix = false;

    public ParsedKeepStatement(int id) {
        super();
    }

    /** Accept the visitor. **/
    public Object jjtAccept(CantoParserVisitor visitor, Object data) {
        return visitor.visit(this, data);
    }

    public void setHasAs(boolean hasAs) {
        this.hasAs = hasAs;
    }

    public void setHasAsThis(boolean hasAsThis) {
        this.hasAsThis = hasAsThis;
    }

    public void setHasDynamicAs(boolean hasDynamicAs) {
        this.hasDynamicAs = hasDynamicAs;
    }

    public void setHasBy(boolean hasBy) {
        this.hasBy = hasBy;
    }

    public void setIsPrefix(boolean isPrefix) {
        this.isPrefix = isPrefix;
    }

    public void init() {
    	if (children != null && children.length > 0) {
            int len = children.length;
    		CantoNode lastChild = getChild(len - 1);
            int i = 0;
            int numNames;
        	if (isPrefix) {
        		numNames = 0;
        	} else {
        		numNames = len;
            	if (len > 1 && lastChild instanceof Instantiation) {
                	numNames--;
            	}
            	if (hasAs || hasDynamicAs || hasBy) {
                	numNames--;
            	}
                NameNode[] names = new NameNode[numNames];

                while (i < numNames) {
                    names[i] = (NameNode) children[i];
                    i++;
                }
                setNames(names);
        	}
        	
            if (hasAs) {
                setAsName((NameNode) children[i]);
                numNames++;
            } else if (hasAsThis) {
                setAsName(new NameNode(Name.THIS));
            } else if (hasDynamicAs) {
                setAsNameGenerator(children[i]);
                numNames++;
            } else if (hasBy) {
                setByName((NameNode) children[i]);
            }
            if (numNames < len) {
                Instantiation instance = (Instantiation) lastChild;
                if (instance.getName() == Name.CONTAINER) {
                    setInContainer(true);
                } else {
                    setTableInstance(instance);
                }
            }
        }
    }
}
